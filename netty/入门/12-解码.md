### netty 解码

将服务器收到的二进制数据流，解码器通过一定规则的解码，把这串二进制数据解析成一个个bytebuf，这个过程就是解码



### 常见问题

解码器抽象的解码过程

ByteToMessageDecoder 这个解码器抽象实现的

步骤：

1. 累加字节流
2. 调用子类的decode方法进行解析（不同的解码器有不同的逻辑）
3. 将ByteBuf向下传播





netty里面有哪些拆箱即用的解码器

固定长度的解码器

行解码器  \n  \r\n 

固定分割符的解码器

长度域解码器





### 解码器的基类 

ByteToMessageDecoder



netty中常见的解码器





### ByteToMessageDecoder 解码步骤

1. 累加字节流
2. 调用子类的decode方法进行解析
3. 将ByteBuf向下传播



```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    // 是 ByteBuf 才解码
    if (msg instanceof ByteBuf) {
        selfFiredChannelRead = true;
        //一个list集合
        CodecOutputList out = CodecOutputList.newInstance();
        try {
            // 是否首次
            first = cumulation == null;
            // 写入cumulation累积
            // 首次cumulation = cumulation EMPTY_BUFFER + msg
            // 将之前的msg 相加写到 cumulation
            cumulation = cumulator.cumulate(ctx.alloc(),
                    first ? Unpooled.EMPTY_BUFFER : cumulation, (ByteBuf) msg);
            // 调用子类 decode 方法进行解码
            callDecode(ctx, cumulation, out);
        } catch (DecoderException e) {
            throw e;
        } catch (Exception e) {
            throw new DecoderException(e);
        } finally {
            try {
                if (cumulation != null && !cumulation.isReadable()) {
                    numReads = 0;
                    cumulation.release();
                    cumulation = null;
                } else if (++numReads >= discardAfterReads) {
                    // We did enough reads already try to discard some bytes, so we not risk to see a OOME.
                    // See https://github.com/netty/netty/issues/4275
                    numReads = 0;
                    discardSomeReadBytes();
                }

                int size = out.size();
                firedChannelRead |= out.insertSinceRecycled();
                // out 里有数据就继续向下传播
                fireChannelRead(ctx, out, size);
            } finally {
                out.recycle();
            }
        }
    } else {
        ctx.fireChannelRead(msg);
    }
}


protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
    try {
        // 如果累计区有可读字节
        while (in.isReadable()) {
            //记录out读到的个数
            final int outSize = out.size();
			// 上次循环成功解码，但ByteBuf里面还有数据可以读
            if (outSize > 0) {
                //向下传播ChannelRead
                fireChannelRead(ctx, out, outSize);
                // 将 size 置为0 ,防止finally 的 fireChannelRead
                out.clear();

                // Check if this handler was removed before continuing with decoding.
                // If it was removed, it is not safe to continue to operate on the buffer.
                //
                // See:
                // - https://github.com/netty/netty/issues/4635
                if (ctx.isRemoved()) {
                    break;
                }
            }
			// 记录可读长度
            int oldInputLength = in.readableBytes();
            // 调用 decode 方法，将成功解码后的数据放入道 out 数组中
            decodeRemovalReentryProtection(ctx, in, out);

            // Check if this handler was removed before continuing the loop.
            // If it was removed, it is not safe to continue to operate on the buffer.
            //
            // See https://github.com/netty/netty/issues/1664
            if (ctx.isRemoved()) {
                break;
            }
			// 调用子类decode方法,没有数据放到 out 中
            //两种情况:
            //1.没读数据
            //2.读了数据，但没解析成对象
            if (out.isEmpty()) {
                if (oldInputLength == in.readableBytes()) {
                    //没读数据，就证明子类decode没有完整的数据包，需要继续接收buff
                    break;
                } else {
                    //  out 没数据，buff读了，但读到的不完整无法解析成对象
                    // 就是解析了一半，接着解析
                    continue;
                }
            }
			
            // out 有数据，但没读buff，这是错误的
            if (oldInputLength == in.readableBytes()) {
                throw new DecoderException(
                    StringUtil.simpleClassName(getClass()) +
                    ".decode() did not read anything but decoded a message.");
            }

            if (isSingleDecode()) {
                break;
            }
        }
    } catch (DecoderException e) {
        throw e;
    } catch (Exception cause) {
        throw new DecoderException(cause);
    }
}


 public static final Cumulator MERGE_CUMULATOR = new Cumulator() {
     @Override
     public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
         if (!cumulation.isReadable() && in.isContiguous()) {
             // If cumulation is empty and input buffer is contiguous, use it directly
             cumulation.release();
             return in;
         }
         try {
             final int required = in.readableBytes();
             // cumulation的最大可写不够就进行扩容
             if (required > cumulation.maxWritableBytes() ||
                 required > cumulation.maxFastWritableBytes() && cumulation.refCnt() > 1 ||
                 cumulation.isReadOnly()) {
                 // Expand cumulation (by replacing it) under the following conditions:
                 // - cumulation cannot be resized to accommodate the additional data
                 // - cumulation can be expanded with a reallocation operation to accommodate but the buffer is
                 //   assumed to be shared (e.g. refCnt() > 1) and the reallocation may not be safe.
                 // 新的cumulation = oldBytes + newBytes;
                 return expandCumulation(alloc, cumulation, in);
             }
             //cumulation，写入in的内容
             cumulation.writeBytes(in, in.readerIndex(), required);
             in.readerIndex(in.writerIndex());
             return cumulation;
         } finally {
             // We must release in all cases as otherwise it may produce a leak if writeBytes(...) throw
             // for whatever release (for example because of OutOfMemoryError)
             in.release();
         }
     }
 };


    static ByteBuf expandCumulation(ByteBufAllocator alloc, ByteBuf oldCumulation, ByteBuf in) {
        int oldBytes = oldCumulation.readableBytes();
        int newBytes = in.readableBytes();
        // 
        int totalBytes = oldBytes + newBytes;
        ByteBuf newCumulation = alloc.buffer(alloc.calculateNewCapacity(totalBytes, MAX_VALUE));
        ByteBuf toRelease = newCumulation;
        try {
            // This avoids redundant checks and stack depth compared to calling writeBytes(...)
            newCumulation.setBytes(0, oldCumulation, oldCumulation.readerIndex(), oldBytes)
                .setBytes(oldBytes, in, in.readerIndex(), newBytes)
                .writerIndex(totalBytes);
            in.readerIndex(in.writerIndex());
            toRelease = oldCumulation;
            return newCumulation;
        } finally {
            toRelease.release();
        }
    }
```







### 	FixedLengthFrameDecoder 固定长度解码器



```java
客户端发送4个数据包
   +---+----+------+----+
   | A | BC | DEFG | HI |
   +---+----+------+----+
   
固定长度为3的解码器：解码生3个固定长度为3数据包
   +-----+-----+-----+
   | ABC | DEF | GHI |
   +-----+-----+-----+
   
public class FixedLengthFrameDecoder extends ByteToMessageDecoder {

    private final int frameLength;

    // 就一个长度参数 
    public FixedLengthFrameDecoder(int frameLength) {
        checkPositive(frameLength, "frameLength");
        this.frameLength = frameLength;
    }

    @Override
    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        Object decoded = decode(ctx, in);
        if (decoded != null) {
            ////读取到数据，就添加到out里面
            out.add(decoded);
        }
    }

   
    protected Object decode(
            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        //小于frameLength返回null,不会添加到out里
        if (in.readableBytes() < frameLength) {
            return null;
        } else {
            //读取一段切片
            return in.readRetainedSlice(frameLength);
        }
    }
}
```







### LineBasedFrameDecoder 行解码器

![](img\2022-09-09 052447.png)

![](img\2022-09-09 052819.png)









```java
public class LineBasedFrameDecoder extends ByteToMessageDecoder {

    /** Maximum length of a frame we're willing to decode.  */
    //行解码器的最大长度,超过可能进入丢弃模式
    private final int maxLength;
    /** Whether or not to throw an exception as soon as we exceed maxLength. */
    //超过最大长度是否立即拋异常
    private final boolean failFast;
    //是否带换行符
    private final boolean stripDelimiter;

    /** True if we're discarding input because we're already over maxLength.  */
    //丢弃模式
    private boolean discarding;
    //丢弃多少字节
    private int discardedBytes;

    /** Last scan position. */
    private int offset;

   
    public LineBasedFrameDecoder(final int maxLength) {
        this(maxLength, true, false);
    }

   
    public LineBasedFrameDecoder(final int maxLength, final boolean stripDelimiter, final boolean failFast) {
        this.maxLength = maxLength;
        this.failFast = failFast;
        this.stripDelimiter = stripDelimiter;
    }

    @Override
    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        Object decoded = decode(ctx, in);
        if (decoded != null) {
            out.add(decoded);
        }
    }

    
    protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {
        //找到 \n  或者 \r\n 结尾的
        // eol 表示换行符当前的下标
        final int eol = findEndOfLine(buffer);
        if (!discarding) {
            if (eol >= 0) {
                final ByteBuf frame;
                // 换行符结尾的 减掉 可读 就得到长度
                final int length = eol - buffer.readerIndex();
                // 换行符的长度
                final int delimLength = buffer.getByte(eol) == '\r'? 2 : 1;
				// 大过最大长度，就进人
                if (length > maxLength) {
                    // 将数据完全丢弃
                    buffer.readerIndex(eol + delimLength);
                    fail(ctx, length);
                    //当前什么事都没干
                    return null;
                }
				//换行符是否算数据包
                if (stripDelimiter) {
                    // 拿到换行符之前的所有数据
                    frame = buffer.readRetainedSlice(length);
                    // 跳过换行符-下次读的时候不让读
                    buffer.skipBytes(delimLength);
                } else {
                    // 读取 length + 换行符的长度
                    frame = buffer.readRetainedSlice(length + delimLength);
                }
                return frame;
            } else {
                // 没找到换行符
                final int length = buffer.readableBytes();
                //大于就进入丢弃模式
                if (length > maxLength) {
                    //丢弃长度
                    discardedBytes = length;
                    //全部都丢掉 readerIndex 到 writerIndex 
                    buffer.readerIndex(buffer.writerIndex());
                    //丢弃模式
                    discarding = true;
                    offset = 0;
                    //是否马上拋异常
                    if (failFast) {
                        //是否马上拋异常
                        fail(ctx, "over " + discardedBytes);
                    }
                }
                //当前什么事都没干
                return null;
            }
        } else {
            if (eol >= 0) {
                //找到换行符了，但之前丢了一段，现在也要把换行符之前的数据都丢掉
                final int length = discardedBytes + eol - buffer.readerIndex();
                final int delimLength = buffer.getByte(eol) == '\r'? 2 : 1;
                //换行符了加上分割符之前的都丢掉
                buffer.readerIndex(eol + delimLength);
                //丢弃模式变会正常模式
                discardedBytes = 0;
                discarding = false;
                //找到所有的无效数据之后再拋异常
                if (!failFast) {
                    fail(ctx, length);
                }
            } else {
                //之前是丢弃模式，现在还是没有找到换行符，进行全部丢弃
                discardedBytes += buffer.readableBytes();
                buffer.readerIndex(buffer.writerIndex());
                // We skip everything in the buffer, we need to set the offset to 0 again.
                offset = 0;
            }
            //丢弃模式下什么都不干
            return null;
        }
    }

    private void fail(final ChannelHandlerContext ctx, int length) {
        fail(ctx, String.valueOf(length));
    }

    private void fail(final ChannelHandlerContext ctx, String length) {
        ctx.fireExceptionCaught(
                new TooLongFrameException(
                        "frame length (" + length + ") exceeds the allowed maximum (" + maxLength + ')'));
    }

    /**
     * Returns the index in the buffer of the end of line found.
     * Returns -1 if no end of line was found in the buffer.
     */
    private int findEndOfLine(final ByteBuf buffer) {
        int totalLength = buffer.readableBytes();
        //找到 \n 结尾的
        int i = buffer.forEachByte(buffer.readerIndex() + offset, totalLength - offset, ByteProcessor.FIND_LF);
        //
        if (i >= 0) {
            offset = 0; 
            //前一个字符是 \r 就 --
            if (i > 0 && buffer.getByte(i - 1) == '\r') {
                //前一个字符是 \r 就 --
                i--;
            }
        } else {	
            offset = totalLength;
        }
        return i;
    }
} 
```





### DelimiterBasedFrameDecoder 分隔符解码器

解码步骤：

行处理器：如果是 \n 或者 \r\n 结尾的 直接使用 LineBasedFrameDecoder

找到最小分隔符：多个分隔符，找到长度最小的

解码：



![](img\2022-09-09 054855.png)



```java

package io.netty.handler.codec;

import static io.netty.util.internal.ObjectUtil.checkPositive;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.internal.ObjectUtil;

import java.util.List;

/**
 * <pre>
 * +--------------+
 * | ABC\nDEF\r\n |
 * +--------------+
 * </pre>
 * a {@link DelimiterBasedFrameDecoder}({@link Delimiters#lineDelimiter() Delimiters.lineDelimiter()})
 * will choose {@code '\n'} as the first delimiter and produce two frames:
 * <pre>
 * +-----+-----+
 * | ABC | DEF |
 * +-----+-----+
 * </pre>
 * rather than incorrectly choosing {@code '\r\n'} as the first delimiter:
 * <pre>
 * +----------+
 * | ABC\nDEF |
 * +----------+
 * </pre>
 */
public class DelimiterBasedFrameDecoder extends ByteToMessageDecoder {
	//分隔符
    private final ByteBuf[] delimiters;
    //最大长度
    private final int maxFrameLength;
    //是否跳过分隔符
    private final boolean stripDelimiter;
    //超过最大长度是否立即拋异常
    private final boolean failFast;
    private boolean discardingTooLongFrame;
    private int tooLongFrameLength;
    /** Set only when decoding with "\n" and "\r\n" as the delimiter.  */
    //当前分隔符是"\n" and "\r\n" 则用lineBasedDecoder
    private final LineBasedFrameDecoder lineBasedDecoder;

   
    public DelimiterBasedFrameDecoder(
            int maxFrameLength, boolean stripDelimiter, boolean failFast, ByteBuf... delimiters) {
        validateMaxFrameLength(maxFrameLength);
        ObjectUtil.checkNonEmpty(delimiters, "delimiters");

        if (isLineBased(delimiters) && !isSubclass()) {
            lineBasedDecoder = new LineBasedFrameDecoder(maxFrameLength, stripDelimiter, failFast);
            this.delimiters = null;
        } else {
            this.delimiters = new ByteBuf[delimiters.length];
            for (int i = 0; i < delimiters.length; i ++) {
                ByteBuf d = delimiters[i];
                validateDelimiter(d);
                this.delimiters[i] = d.slice(d.readerIndex(), d.readableBytes());
            }
            lineBasedDecoder = null;
        }
        this.maxFrameLength = maxFrameLength;
        this.stripDelimiter = stripDelimiter;
        this.failFast = failFast;
    }

        /** Returns true if the delimiters are "\n" and "\r\n".  */
    private static boolean isLineBased(final ByteBuf[] delimiters) {
        if (delimiters.length != 2) {
            return false;
        }
        ByteBuf a = delimiters[0];
        ByteBuf b = delimiters[1];
        if (a.capacity() < b.capacity()) {
            a = delimiters[1];
            b = delimiters[0];
        }
        return a.capacity() == 2 && b.capacity() == 1
                && a.getByte(0) == '\r' && a.getByte(1) == '\n'
                && b.getByte(0) == '\n';
    }


    private boolean isSubclass() {
        return getClass() != DelimiterBasedFrameDecoder.class;
    }

    @Override
    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        //入口
        Object decoded = decode(ctx, in);
        if (decoded != null) {
            out.add(decoded);
        }
    }

   
    protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {
        //是否是行分隔符
        if (lineBasedDecoder != null) {
            return lineBasedDecoder.decode(ctx, buffer);
        }
        // Try all delimiters and choose the delimiter which yields the shortest frame.
        //找到最小分隔符的长度
        int minFrameLength = Integer.MAX_VALUE;
        ByteBuf minDelim = null;
        for (ByteBuf delim: delimiters) {
            int frameLength = indexOf(buffer, delim);
            if (frameLength >= 0 && frameLength < minFrameLength) {
                //最小分隔符的长度
                minFrameLength = frameLength;
                //最小分隔符
                minDelim = delim;
            }
        }

        if (minDelim != null) {
            //分隔符的长度
            int minDelimLength = minDelim.capacity();
            ByteBuf frame;

            if (discardingTooLongFrame) {
                // We've just finished discarding a very large frame.
                // Go back to the initial state.
                //改变丢弃模式
                discardingTooLongFrame = false;
                // \r\n 最小分隔符的长度 minDelimLength
                // minFrameLength ：读指针到分割符的长度
                buffer.skipBytes(minFrameLength + minDelimLength);
				// 计算抛弃的长度
                int tooLongFrameLength = this.tooLongFrameLength;
                this.tooLongFrameLength = 0;
                if (!failFast) {
                    //
                    fail(tooLongFrameLength);
                }
                //丢弃模式下啥都不干
                return null;
            }
			// 找到的分隔符大于最大长度
            if (minFrameLength > maxFrameLength) {
                // Discard read frame.
                //这一段都丢掉
                buffer.skipBytes(minFrameLength + minDelimLength);
                //拋异常--一整段都丢掉
                fail(minFrameLength);
                return null;
            }
			
            //是否跳过分隔符
            if (stripDelimiter) {
                //只读分隔符前面的
                frame = buffer.readRetainedSlice(minFrameLength);
                //跳过分隔符，防止下次读到
                buffer.skipBytes(minDelimLength);
            } else {
                //连分隔符一起读
                frame = buffer.readRetainedSlice(minFrameLength + minDelimLength);
            }
			//返回读的数据
            return frame;
        } else {
            //没有读到换行符
            if (!discardingTooLongFrame) {
                //readableBytes = write-read
                //非丢弃模式下：可读大于maxFrameLength这时候才进入丢弃模式
                if (buffer.readableBytes() > maxFrameLength) {
                    // Discard the content of the buffer until a delimiter is found.
                    // 丢掉可读的长度，因为这一段都没分割符--可读长度已经大过最大长度了
                    tooLongFrameLength = buffer.readableBytes();
                    buffer.skipBytes(buffer.readableBytes());
                    //进入丢弃模式
                    discardingTooLongFrame = true;
                    if (failFast) {
                        fail(tooLongFrameLength);
                    }
                }
            } else {
                // Still discarding the buffer since a delimiter is not found.
                //之前是丢弃模式，现在还没找到分隔符，这一段也都丢掉
                tooLongFrameLength += buffer.readableBytes();
                buffer.skipBytes(buffer.readableBytes());
            }
            return null;
        }
    }

    private void fail(long frameLength) {
        if (frameLength > 0) {
            throw new TooLongFrameException(
                            "frame length exceeds " + maxFrameLength +
                            ": " + frameLength + " - discarded");
        } else {
            throw new TooLongFrameException(
                            "frame length exceeds " + maxFrameLength +
                            " - discarding");
        }
    }

    /**
     * Returns the number of bytes between the readerIndex of the haystack and
     * the first needle found in the haystack.  -1 is returned if no needle is
     * found in the haystack.
     */
    private static int indexOf(ByteBuf haystack, ByteBuf needle) {
        for (int i = haystack.readerIndex(); i < haystack.writerIndex(); i ++) {
            int haystackIndex = i;
            int needleIndex;
            for (needleIndex = 0; needleIndex < needle.capacity(); needleIndex ++) {
                if (haystack.getByte(haystackIndex) != needle.getByte(needleIndex)) {
                    break;
                } else {
                    haystackIndex ++;
                    if (haystackIndex == haystack.writerIndex() &&
                        needleIndex != needle.capacity() - 1) {
                        return -1;
                    }
                }
            }

            if (needleIndex == needle.capacity()) {
                // Found the needle from the haystack!
                return i - haystack.readerIndex();
            }
        }
        return -1;
    }

    private static void validateDelimiter(ByteBuf delimiter) {
        ObjectUtil.checkNotNull(delimiter, "delimiter");
        if (!delimiter.isReadable()) {
            throw new IllegalArgumentException("empty delimiter");
        }
    }

    private static void validateMaxFrameLength(int maxFrameLength) {
        checkPositive(maxFrameLength, "maxFrameLength");
    }
}
```





### LengthFieldBasedFrameDecoder长度域解码器

1. 计算需要抽取的数据包长度
2. 跳过字节的处理
3. 丢弃模式下的处理



```java
//相对于 readindex 的偏移量
private final int lengthFieldOffset;
//长度域的长度有几位：默认：1, 2, 3, 4, or 8 ，3位十六进制，长度最大4095了,可以了，
//所以这个lengthFieldLength默认只能是1, 2, 3, 4, or 8 
private final int lengthFieldLength;
//长度域的尾部的偏移量或者Actual Content开始的偏移量
private final int lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength
//真实的长度域的尾部或者Actual Content开始的下标   
int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;


下图1：
    lengthFieldOffset = 2  表示相对于开始偏移2位
    lengthFieldLength = 2  表示从00开始接下来2位表示长度
图中：lengthFieldLength = 0004 ,表示接下来的4个字节都是一个数据包

开始偏移2个字节 + 加上 2 字节的长度域 + 0004 长度的字节  整个数据包的长度是 8 
    
    
额外参数：
    lengthAdjustment ： lengthFieldLength 里面表示的不一定是实际的数据包长度，需要这个参数，加上一小段
    initialBytesToStrip：解码的时候跳过一些长度，例如把表示长度的前部分去掉
    
   lengthFieldOffset   = 0
   lengthFieldLength   = 2
   lengthAdjustment    = 0
   initialBytesToStrip = 0 (= do not strip header)
    
   Length = 0x000C = 12
   BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
   +--------+----------------+      +--------+----------------+
   | Length | Actual Content |----->| Length | Actual Content |
   | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |
   +--------+----------------+      +--------+----------------+
    
    
   lengthFieldOffset   =  0
   lengthFieldLength   =  2
   lengthAdjustment    = -2 (= the length of the Length field)
   initialBytesToStrip =  0

   Length = 0x000E 表示后面长度14个字节
   lengthAdjustment    = -2   实际应该是14，但 lengthAdjustment =2 表示要减掉2个字节，所以Actual Content只有12
BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
   +--------+----------------+      +--------+----------------+
   | Length | Actual Content |----->| Length | Actual Content |
   | 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |
   +--------+----------------+      +--------+----------------+    
    
   lengthFieldOffset   = 0
   lengthFieldLength   = 2
   lengthAdjustment    = 0
   initialBytesToStrip = 2 (= the length of the Length field)
    
   initialBytesToStrip = 2 表示实际解码处理的长度减掉一部分，本应该有 Length 两字节的
   BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
   +--------+----------------+      +----------------+
   | Length | Actual Content |----->| Actual Content |
   | 0x000C | "HELLO, WORLD" |      | "HELLO, WORLD" |
   +--------+----------------+      +----------------+ 
    
    
    
    
 

```

图1:

![](img\2022-09-09 062137.png)



​																	

![](img\2022-09-09 074043.png)







```java

package io.netty.handler.codec;

import static io.netty.util.internal.ObjectUtil.checkNotNull;
import static io.netty.util.internal.ObjectUtil.checkPositive;
import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;

import java.nio.ByteOrder;
import java.util.List;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

/**
 * <pre>
 * <b>lengthFieldOffset</b>   = <b>0</b>
 * <b>lengthFieldLength</b>   = <b>2</b>
 * lengthAdjustment    = 0
 * initialBytesToStrip = 0 (= do not strip header)
 *
 * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
 * +--------+----------------+      +--------+----------------+
 * | Length | Actual Content |----->| Length | Actual Content |
 * | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |
 * +--------+----------------+      +--------+----------------+
 * </pre>
 *
 * <h3>2 bytes length field at offset 0, strip header</h3>
 *
 * Because we can get the length of the content by calling
 * {@link ByteBuf#readableBytes()}, you might want to strip the length
 * field by specifying <tt>initialBytesToStrip</tt>.  In this example, we
 * specified <tt>2</tt>, that is same with the length of the length field, to
 * strip the first two bytes.
 * <pre>
 * lengthFieldOffset   = 0
 * lengthFieldLength   = 2
 * lengthAdjustment    = 0
 * <b>initialBytesToStrip</b> = <b>2</b> (= the length of the Length field)
 *
 * BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
 * +--------+----------------+      +----------------+
 * | Length | Actual Content |----->| Actual Content |
 * | 0x000C | "HELLO, WORLD" |      | "HELLO, WORLD" |
 * +--------+----------------+      +----------------+
 * </pre>
 *
 * <h3>2 bytes length field at offset 0, do not strip header, the length field
 *     represents the length of the whole message</h3>
 *
 * In most cases, the length field represents the length of the message body
 * only, as shown in the previous examples.  However, in some protocols, the
 * length field represents the length of the whole message, including the
 * message header.  In such a case, we specify a non-zero
 * <tt>lengthAdjustment</tt>.  Because the length value in this example message
 * is always greater than the body length by <tt>2</tt>, we specify <tt>-2</tt>
 * as <tt>lengthAdjustment</tt> for compensation.
 * <pre>
 * lengthFieldOffset   =  0
 * lengthFieldLength   =  2
 * <b>lengthAdjustment</b>    = <b>-2</b> (= the length of the Length field)
 * initialBytesToStrip =  0
 *
 * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
 * +--------+----------------+      +--------+----------------+
 * | Length | Actual Content |----->| Length | Actual Content |
 * | 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |
 * +--------+----------------+      +--------+----------------+
 * </pre>
 *
 * <h3>3 bytes length field at the end of 5 bytes header, do not strip header</h3>
 *
 * The following message is a simple variation of the first example.  An extra
 * header value is prepended to the message.  <tt>lengthAdjustment</tt> is zero
 * again because the decoder always takes the length of the prepended data into
 * account during frame length calculation.
 * <pre>
 * <b>lengthFieldOffset</b>   = <b>2</b> (= the length of Header 1)
 * <b>lengthFieldLength</b>   = <b>3</b>
 * lengthAdjustment    = 0
 * initialBytesToStrip = 0
 *
 * BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
 * +----------+----------+----------------+      +----------+----------+----------------+
 * | Header 1 |  Length  | Actual Content |----->| Header 1 |  Length  | Actual Content |
 * |  0xCAFE  | 0x00000C | "HELLO, WORLD" |      |  0xCAFE  | 0x00000C | "HELLO, WORLD" |
 * +----------+----------+----------------+      +----------+----------+----------------+
 * </pre>
 *
 * <h3>3 bytes length field at the beginning of 5 bytes header, do not strip header</h3>
 *
 * This is an advanced example that shows the case where there is an extra
 * header between the length field and the message body.  You have to specify a
 * positive <tt>lengthAdjustment</tt> so that the decoder counts the extra
 * header into the frame length calculation.
 * <pre>
 * lengthFieldOffset   = 0
 * lengthFieldLength   = 3
 * <b>lengthAdjustment</b>    = <b>2</b> (= the length of Header 1)
 * initialBytesToStrip = 0
 *
 * BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
 * +----------+----------+----------------+      +----------+----------+----------------+
 * |  Length  | Header 1 | Actual Content |----->|  Length  | Header 1 | Actual Content |
 * | 0x00000C |  0xCAFE  | "HELLO, WORLD" |      | 0x00000C |  0xCAFE  | "HELLO, WORLD" |
 * +----------+----------+----------------+      +----------+----------+----------------+
 * </pre>
 *
 * <h3>2 bytes length field at offset 1 in the middle of 4 bytes header,
 *     strip the first header field and the length field</h3>
 *
 * This is a combination of all the examples above.  There are the prepended
 * header before the length field and the extra header after the length field.
 * The prepended header affects the <tt>lengthFieldOffset</tt> and the extra
 * header affects the <tt>lengthAdjustment</tt>.  We also specified a non-zero
 * <tt>initialBytesToStrip</tt> to strip the length field and the prepended
 * header from the frame.  If you don't want to strip the prepended header, you
 * could specify <tt>0</tt> for <tt>initialBytesToSkip</tt>.
 * <pre>
 * lengthFieldOffset   = 1 (= the length of HDR1)
 * lengthFieldLength   = 2
 * <b>lengthAdjustment</b>    = <b>1</b> (= the length of HDR2)
 * <b>initialBytesToStrip</b> = <b>3</b> (= the length of HDR1 + LEN)
 *
 * BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
 * +------+--------+------+----------------+      +------+----------------+
 * | HDR1 | Length | HDR2 | Actual Content |----->| HDR2 | Actual Content |
 * | 0xCA | 0x000C | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
 * +------+--------+------+----------------+      +------+----------------+
 * </pre>
 *
 * <h3>2 bytes length field at offset 1 in the middle of 4 bytes header,
 *     strip the first header field and the length field, the length field
 *     represents the length of the whole message</h3>
 *
 * Let's give another twist to the previous example.  The only difference from
 * the previous example is that the length field represents the length of the
 * whole message instead of the message body, just like the third example.
 * We have to count the length of HDR1 and Length into <tt>lengthAdjustment</tt>.
 * Please note that we don't need to take the length of HDR2 into account
 * because the length field already includes the whole header length.
 * <pre>
 * lengthFieldOffset   =  1
 * lengthFieldLength   =  2
 * <b>lengthAdjustment</b>    = <b>-3</b> (= the length of HDR1 + LEN, negative)
 * <b>initialBytesToStrip</b> = <b> 3</b>
 *
 * BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
 * +------+--------+------+----------------+      +------+----------------+
 * | HDR1 | Length | HDR2 | Actual Content |----->| HDR2 | Actual Content |
 * | 0xCA | 0x0010 | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
 * +------+--------+------+----------------+      +------+----------------+
 * </pre>
 * @see LengthFieldPrepender
 */
public class LengthFieldBasedFrameDecoder extends ByteToMessageDecoder {

    private final ByteOrder byteOrder;
    private final int maxFrameLength;
    private final int lengthFieldOffset;
    private final int lengthFieldLength;
    private final int lengthFieldEndOffset;
    private final int lengthAdjustment;
    private final int initialBytesToStrip;
    private final boolean failFast;
    private boolean discardingTooLongFrame;
    private long tooLongFrameLength;
    private long bytesToDiscard;
    private int frameLengthInt = -1;

   
    public LengthFieldBasedFrameDecoder(
            ByteOrder byteOrder, int maxFrameLength, int lengthFieldOffset, int lengthFieldLength,
            int lengthAdjustment, int initialBytesToStrip, boolean failFast) {

        this.byteOrder = checkNotNull(byteOrder, "byteOrder");

        checkPositive(maxFrameLength, "maxFrameLength");

        checkPositiveOrZero(lengthFieldOffset, "lengthFieldOffset");

        checkPositiveOrZero(initialBytesToStrip, "initialBytesToStrip");

        if (lengthFieldOffset > maxFrameLength - lengthFieldLength) {
            throw new IllegalArgumentException(
                    "maxFrameLength (" + maxFrameLength + ") " +
                    "must be equal to or greater than " +
                    "lengthFieldOffset (" + lengthFieldOffset + ") + " +
                    "lengthFieldLength (" + lengthFieldLength + ").");
        }

        this.maxFrameLength = maxFrameLength;
        this.lengthFieldOffset = lengthFieldOffset;
        this.lengthFieldLength = lengthFieldLength;
        this.lengthAdjustment = lengthAdjustment;
        this.lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength;
        this.initialBytesToStrip = initialBytesToStrip;
        this.failFast = failFast;
    }

    @Override
    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        入口
        Object decoded = decode(ctx, in);
        if (decoded != null) {
            out.add(decoded);
        }
    }
	 //丢弃模式下的处理
    private void discardingTooLongFrame(ByteBuf in) {
       	//上一次还需要丢弃的长度
        long bytesToDiscard = this.bytesToDiscard;
        //和当前可读长度比较哪个小，就丢弃那个
        int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());
        in.skipBytes(localBytesToDiscard);
        bytesToDiscard -= localBytesToDiscard;
        this.bytesToDiscard = bytesToDiscard;
		//拋异常
        failIfNecessary(false);
    }

    private static void failOnNegativeLengthField(ByteBuf in, long frameLength, int lengthFieldEndOffset) {
        in.skipBytes(lengthFieldEndOffset);
        throw new CorruptedFrameException(
           "negative pre-adjustment length field: " + frameLength);
    }

    private static void failOnFrameLengthLessThanLengthFieldEndOffset(ByteBuf in,
                                                                      long frameLength,
                                                                      int lengthFieldEndOffset) {
        in.skipBytes(lengthFieldEndOffset);
        throw new CorruptedFrameException(
           "Adjusted frame length (" + frameLength + ") is less " +
              "than lengthFieldEndOffset: " + lengthFieldEndOffset);
    }

    private void exceededFrameLength(ByteBuf in, long frameLength) {
		//计算的长度大于最大长度
        //可读长度下还有丢弃多少长度
        //discard表示还有丢弃的长度
        long discard = frameLength - in.readableBytes();
        tooLongFrameLength = frameLength;

        if (discard < 0) {
            // buffer contains more bytes then the frameLength so we can discard all now
            //计算的长度要丢弃的长度frameLength 小于可读长度，直接丢弃这段
            in.skipBytes((int) frameLength);
        } else {
            // Enter the discard mode and discard everything received so far.
            //进入丢弃模式
            discardingTooLongFrame = true;
            //bytesToDiscard表示还有丢弃的长度,下次丢弃模式下，还有丢弃的长度
            bytesToDiscard = discard;
            in.skipBytes(in.readableBytes());
        }
        //拋异常
        failIfNecessary(true);
    }

    private static void failOnFrameLengthLessThanInitialBytesToStrip(ByteBuf in,
                                                                     long frameLength,
                                                                     int initialBytesToStrip) {
        in.skipBytes((int) frameLength);
        throw new CorruptedFrameException(
           "Adjusted frame length (" + frameLength + ") is less " +
              "than initialBytesToStrip: " + initialBytesToStrip);
    }

    /**
     * Create a frame out of the {@link ByteBuf} and return it.
     *
     * @param   ctx             the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to
     * @param   in              the {@link ByteBuf} from which to read data
     * @return  frame           the {@link ByteBuf} which represent the frame or {@code null} if no frame could
     *                          be created.
     */
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        long frameLength = 0;
        if (frameLengthInt == -1) { // new frame
			
            //丢弃模式下的处理
            if (discardingTooLongFrame) {
                discardingTooLongFrame(in);
            }
            // lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength
			//可读的长度还没有长度域长
            if (in.readableBytes() < lengthFieldEndOffset) {
                return null;
            }
			//真实的长度域的尾部或者Actual Content开始的下标   
            int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;
            //获取lengthFieldLength的值--可以理解为Actual Content的length
            frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);
			//lengthFieldLength的值小于零异常情况
            if (frameLength < 0) {
                failOnNegativeLengthField(in, frameLength, lengthFieldEndOffset);
            }
			//实际要读的长度 = Actual Content + lengthAdjustment (调整的长度)+ 长度域的长度 
            frameLength += lengthAdjustment + lengthFieldEndOffset;
			//实际要读的长度还没长度域的长度--异常情况
            if (frameLength < lengthFieldEndOffset) {
                failOnFrameLengthLessThanLengthFieldEndOffset(in, frameLength, lengthFieldEndOffset);
            }
			
            //超过最大值的处理
            if (frameLength > maxFrameLength) {
                //超过最大值的处理
                exceededFrameLength(in, frameLength);
                //啥事不干--不往out添加数据
                return null;
            }
            // never overflows because it's less than maxFrameLength
            frameLengthInt = (int) frameLength;
        }
        // 可读的还没实际要读的证明数据还没发完过来
        if (in.readableBytes() < frameLengthInt) { // frameLengthInt exist , just check buf
            return null;
        }
        //跳过的长度比实际长度还要长--异常情况
        if (initialBytesToStrip > frameLengthInt) {
            failOnFrameLengthLessThanInitialBytesToStrip(in, frameLength, initialBytesToStrip);
        }
        //跳过字节
        in.skipBytes(initialBytesToStrip);

        // extract frame
        //正常拿到数据
        int readerIndex = in.readerIndex();
        int actualFrameLength = frameLengthInt - initialBytesToStrip;
        //正常提前数据
        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);
        in.readerIndex(readerIndex + actualFrameLength);
        frameLengthInt = -1; // start processing the next frame
        
        return frame;
    }

    /**
     * Decodes the specified region of the buffer into an unadjusted frame length.  The default implementation is
     * capable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer.  Override this method to
     * decode the length field encoded differently.  Note that this method must not modify the state of the specified
     * buffer (e.g. {@code readerIndex}, {@code writerIndex}, and the content of the buffer.)
     *
     * @throws DecoderException if failed to decode the specified region
     */
    protected long getUnadjustedFrameLength(ByteBuf buf, int offset, int length, ByteOrder order) {
        buf = buf.order(order);
        long frameLength;
        switch (length) {
        case 1:
            frameLength = buf.getUnsignedByte(offset);
            break;
        case 2:
            frameLength = buf.getUnsignedShort(offset);
            break;
        case 3:
            frameLength = buf.getUnsignedMedium(offset);
            break;
        case 4:
            frameLength = buf.getUnsignedInt(offset);
            break;
        case 8:
            frameLength = buf.getLong(offset);
            break;
        default:
            throw new DecoderException(
                    "unsupported lengthFieldLength: " + lengthFieldLength + " (expected: 1, 2, 3, 4, or 8)");
        }
        return frameLength;
    }

    private void failIfNecessary(boolean firstDetectionOfTooLongFrame) {
        if (bytesToDiscard == 0) {
            // Reset to the initial state and tell the handlers that
            // the frame was too large.
            long tooLongFrameLength = this.tooLongFrameLength;
            this.tooLongFrameLength = 0;
            discardingTooLongFrame = false;
            if (!failFast || firstDetectionOfTooLongFrame) {
                fail(tooLongFrameLength);
            }
        } else {
            // Keep discarding and notify handlers if necessary.
            if (failFast && firstDetectionOfTooLongFrame) {
                fail(tooLongFrameLength);
            }
        }
    }

    /**
     * Extract the sub-region of the specified buffer.
     */
    protected ByteBuf extractFrame(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {
        return buffer.retainedSlice(index, length);
    }

    private void fail(long frameLength) {
        if (frameLength > 0) {
            throw new TooLongFrameException(
                            "Adjusted frame length exceeds " + maxFrameLength +
                            ": " + frameLength + " - discarded");
        } else {
            throw new TooLongFrameException(
                            "Adjusted frame length exceeds " + maxFrameLength +
                            " - discarding");
        }
    }
}
```









### 总结

netty 提供了很多解码器，我们不需要自己写，直接用就好来了

