### 索引失效

七字口诀：**模 型 数 空 运 最 快**

模 : 模糊查询，使用like查询 % 开头

型：数据类型错误

数：对索引字段使用内部函数

空：索引列是null

运：索引列进行四则运算

最：复合索引不按索引最左开始查找

快：全表查找预计比索引更快



不：不等于，not in 

字：字符编码不一致

注意：is null 是会走索引的





### 正确的回答mysql索引会失效

- **不规范的使用：使用 <>， != ，Not In ，like已 '%...'开头，对字段表达式操作**

  注意：

  is null 是会走索引的 相当与常量，可以走任何索引

  col = key or col is null ，ref_or_null，优先得到 col = key 的情况（测试加上 limit ）

- **MySQL 优化器发现不用索引，更快**

  原因：查询数据占全表的比例很大-->官方文档说是 30%但不对，实际官方也说了很复杂不固定，优化器认为全表扫描更合适

- **还有一个bug  使用  where name='xxxxx' order by id limit 1** 

  应该是使用 name 索引访问，但是优化器最后却选择通过主键id进行扫描

  原因：优化器认为排序是个昂贵的操作，所以为了避免排序，且它**认为** limit n 的 n 

  如果很小的话即使使用全表扫描也能很快执行完，所以它选择了全表扫描

- **范围查询的时候，这个范围超过一定个数**

  解决：使用 force index ，和上面的查询数据占全表的比例很大一个道理

- **select  * from  order by 无法保证一定走索引**  

  原因：由于是 * 优化器会认为排序的代价大于全表扫描

  解决：select  字段 from  order by 字段

- **order by desc** 索引是生序，你使用的是降序





### 索引失效

两种情况：

第一种：不规范使用sql与索引

例如：sql 里面 not  <>  ，字段使用了函数，查询字段的类型不匹配，没有使用索引的最左匹配原则

第二种：优化器认为，全表扫描比走索引更快

例如：其中这也分两种情况

一种：查询的数据超过总量一定的比例

当然这30%是官方里说的，但它同时也说了，这个范围是多方面因素影响，不一定30% ，

10% 也有可能

一种：走索引确实慢的

特别体现在 select  *     order by     limit

1. select  *  + limit 很小，直接扫全表返回一条就好，limit 1 就有可能出现，limit 2 我就没发现过

2. select  *  + order by  的深分页，分页之前的数据都需要回表，这个操作是很昂贵的

   解决：不要select * ，或者 修改分页sql，传上一个最大的id，还有就是 子查询拿到数据的id，再去查

   ​			另一个使用索引（覆盖）

3. oder by 生序和降序问题，如何内存够的会，使用 filesort ，正常都会够的有1G内存可以

   但是有些机器内存就是不够，没办法会全表扫描

   解决：将索引的顺序弄对（降序高版本才有），或者加多一条对应顺序的索引，就不会使用 filesort 

   ​	        实在没办法加内存也是一种方法，调大 filesort  内存











### 面试误区

使用 or 不走索引的，建议使用 union all

这是有误的  or  两边都有索引还是会走索引的，使用的是索引合并（单表有效）



or 两边相同列，有索引，走索引

or 两边不同列，有索引，走索引，还是索引合并



还有 union all 有 两边的并集问题

使用 union  去重性能又达不到



group by 默认排序，可以使用 order by null 避免









