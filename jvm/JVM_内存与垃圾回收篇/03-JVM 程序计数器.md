### 程序计数器

PC寄存器用来存储线程指向下一条指令的地址，也即将要执行的指令代码。

是线程私有的，由执行引擎读取下一条指令，然后执行指令，执行后又回到PC 寄存器上获取下一条指令地址，如此反复



JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟

更加贴切（也称为程序钩子或指令计数器--代码运行到哪了还有下一条指令在哪）



它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。



在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。



任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。



它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。



字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。



它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。

（GC 在堆中，方法区）

（OOM 在堆中，方法区，虚拟机栈，本地方法栈都有可能发生）



![](images\image-20200705155728557.png)



执行引擎执行完一条指令，然后又到PC 寄存器上取下一条指令地址，然后执行，执行后又回到PC 寄存器上取下一条指令地址，如此反复





### 代码演示

我们首先写一个简单的代码

```java
/**程序计数器
 * @author: qinjp
 * @create: 2022-07-05
 */
public class PCRegisterTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;
    }
}
```

然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。

```bash
0: bipush        10
2: istore_1
3: bipush        20
5: istore_2
6: iload_1
7: iload_2
8: iadd
9: istore_3
10: return
```

通过PC寄存器，我们就可以知道当前程序执行到哪一步了 



![](images\image-20200705161007423.png)





### 程序执行流程

执行引擎通过  --> PC寄存器 --> 拿到下一条指令的地址 --> 执行操作指令（操作局部变量表和操作数栈）--> 底层翻译成机器指令 01 --> CPU执行 --> 完成之后又回到PC寄存器 --> 拿到下一条指令的地址 --> 反复操作





### 面试重点

#### 使用PC寄存器存储字节码指令地址有什么用呢？

答：明确下一条应该执行什么样的字节码指令



#### 为什么使用PC寄存器记录当前线程执行地址呢？

答：可以明确下一条应该执行什么样的字节码指令



因为CPU需要不停的切换各个线程，这时候切换回来以后，就得需要知道接着从哪开始继续执行。

JVM就是通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。



#### PC寄存器为什么被设定为私有的？

答：私有各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

如果不线程私有，必然产生相互干扰的情况

![](images\image-20200705161812542.png)





### CPU时间片

CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。

在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。

但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

![](images\image-20200705161849557.png)

由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令