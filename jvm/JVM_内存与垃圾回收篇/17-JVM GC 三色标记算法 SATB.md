### 三色标记算法

vm垃圾回收期使用的，在并行标记的时候的一种算法，CMS/G1中的核心算法



把对象从逻辑上分为三种颜色，分别是黑色，灰色，白色

- 黑 色：自身和成员变量均已标记
- 灰色：自身被标记，成员变量未被标记
- 白色：未被标记的对象



### 漏标

    当进行并发标记的时候此时C是一个垃圾对象，是要被回收的，如果此时对象B指向对象C的引用没有了，但是A指向了C，那么此时这个对象C就会找不到了，原因是因为通过B已经找不到C了，但是此时A指向了C，C是有新引用的不能被回收（A是黑色的不会再被扫描，在重新标记阶段就不会找到C）

![](images\20200530131109992.png)



### 解决漏标

只要能跟踪到A指向了C，或者跟踪到B指向C消失。

**incremental update-**-增量更新，

关注引用的增加，当A指向C的时候就把这个A变成一个灰色对象，这样在重新扫描的时候就可以扫描的到



SATB snapshot at the beginning --关注引用的消失，当时B指向C的引用消失了，就把这个引用推到GC的堆栈（都是灰色对象指向白色对象的引用），保证C还可以被GC扫描到（因为存在这个引用的一个记录在GC的堆栈中，所以扫描的时候还是可以找到C这个对象）

SATB 一个快照标记算法，创建了一个对象图，它是堆的一个逻辑“快照”。使用了SATB write barrier来解决这个问题，发生了引用的变化，就把这个引用推到dirty card queue，然后通过线程更新到 RSet  里面









### 三色标记算法的应用

- CMS中使用，漏标采用增量更新

- G1中使用，漏标采用SATB



### 使用SATB的原因

1. 因为增量更新会在重新标记的时候将从黑色变成灰色的对象在扫描一遍，会更费时。
2. 使用SATB就会大大减少扫描对象，原因是只多扫描在GC堆栈中发生改变的引用（和G1的一个RSet进行配合，RSet为每个）

