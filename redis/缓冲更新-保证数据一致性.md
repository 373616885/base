### Cache Aside 机制

一个老外提出的更新机制（缓冲边上--就是已数据库为主，写完再操作边上的缓存）

核心：新更新数据，再跟新缓存的的策略



我们实际做法：更新数据的时候，先更新数据库，然后删除缓存（删除缓存更方便，修改缓存不好控制），等下次查询查不到就去查数据库，然后设置缓存



出现的问题：

两个请求：A 查询操作，B 更新操作，产生下面的情况

![](img\20220914142941238.png)



条件：

1. 缓冲没有数据（开始的时候或者缓存过期的时候）
2. 请求 A 开始查询到一个旧值（没有马上返回，等 B 更新操作完成后，才返回，就是查询在先且比修改操作更慢 --读大于写操作很难出现）
3. 请求 B 将新值写入数据库
4. 请求 B 删除缓存
5. 请求 A 将旧值写入缓存

这时候就会发生脏数据



这个发生的概率很小

1. 读操作时无数据（开始的时候或者缓存过期的时候）
2. 读操作的同时，一个写操作同时进行
3. 读操作时长大于写操作（这个就很难了）
4. 读操作与写操作并发是，读到的是旧值（RR 事务隔离级别概率挺大的有一半呢）

第三条，读操作大于写操作这个就很难，加上同时满足 4 条，就更难了



解决办法：

延迟双删，在第一次删除之后，延迟 2s 再删除

不过没有本质解决问题，特殊情况，延迟 2s ，查询操作还没完成（概率几乎没有了）





































































